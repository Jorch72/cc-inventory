--master computer
--this program oversees the storage and retrieval of items in the storage system.

--initial configuration defaults
local config = {
	--master configuration file
	--in a north-facing setup (master north of service holes), rows are east-west and columns are north-south.
	--facing is determined by which direction the master computer is from the service holes.
	facing = 1,
	layers = 1,
	rows = 6,
	columns = 6,
	layout = {
		--layout coordinates start with 1, 1 in the upper-left.
		rows = {1, 3, 5, 7, 9, 11},
		layers = {
			--column coordinates.
			{1, 3, 5, 7, 9, 11},
			{2, 4, 6 ,8, 10, 12},
		},
		shafts = {
			--row coordinate first.
			{6, 5},
			{6, 7},
		},
		bases = {
			--bases along the outer walls for the item i/o interfaces.
			--row coordinate first.
			{1, 6},
			{7, 12},
			{12, 6},
			{7, 1},
		},
		--master coords used to transform gps coordinates and base coordinates for actual pick-up and drop-off coords.
		master = {5, 6},
	},
	retrievalFlightDelay = 1,
	intakeFlightDelay = 0.4,
	storageBlocks = {
		{
			name = "minecraft:chest",
			slots = 27,
			slotSize = 64,
		},
	},
	locations = {},
	baseCode = "",
	databasePath = "/storagedata",
}

if not os.loadAPI("base") then error("Could not load base API!") end
if not os.loadAPI("configuration") then error("Could not load configuration API!") end
if fs.exists("master.conf") then
	config = configuration.load("master.conf")
else
	--initial setup
	print("Initial Setup for Master Storage Controller")
	while not os.getComputerLabel() do
		print("Please provide a label for this computer.")
		write("> ")
		local label = read()
		if #label >= 1 then
			os.setComputerLabel(label)
			break
		else
			print("A label is required!")
		end
	end
	do
		local loc = vector.new(gps.locate())
		if loc.y == 0 then
			local x, y, z
			repeat
				print("What is this station's X coordinate?")
				print("Use the location of the master controller (this computer).")
				write("> ")
				x = tonumber(read())
				if not (x and x == math.floor(x)) then
					print("A valid integer is required!")
					x = nil
				end
			until x
			repeat
				print("What is this station's Y coordinate?")
				print("Use the location of the master controller (this computer).")
				write("> ")
				y = tonumber(read())
				if not (y and y == math.floor(y) and y > 0) then
					print("A valid positive integer is required!")
					y = nil
				end
			until y
			repeat
				print("What is this station's Z coordinate?")
				print("Use the location of the master controller (this computer).")
				write("> ")
				z = tonumber(read())
				if not (z and z == math.floor(z)) then
					print("A valid integer is required!")
					z = nil
				end
			until z
			loc = vector.new(x, y, z)
		end
		config.location = loc
	end
	while true do
		print("Which direction does this storage station face?")
		print("Determine the direction by standing at the center torch and looking toward the master controller computer (this computer).")
		print("Enter 1 - 4, corresponding to the correct direction:")
		print("1. north      2. east")
		print("3. south      4. west")
		write("> ") 
		local direction = tonumber(read())
		if direction and direction == math.floor(direction) and direction >= 1 and direction <= 4 then
			config.facing = direction
			break
		else
			print("A valid direction is required!")
		end
	end
	do
		local masterVec = vector.new(config.layout.master[1], 0, config.layout.master[2])
		local transformVec = {
			{vector.new(-2, 0, 1), vector.new(-2, 0, -1)},
			{vector.new(1, 0, 2), vector.new(-1, 0, 2)},
			{vector.new(2, 0, -1), vector.new(2, 0, 1)},
			{vector.new(-1, 0, -2), vector.new(1, 0, -2)},
		}
		local facingVec = {
			vector.new(1, 0, 1),
			vector.new(-1, 0, 1),
			vector.new(-1, 0, -1),
			vector.new(1, 0, -1),
		}
		for i = 1, 4 do
			if config.layout.bases[i] then
				local baseVec = vector.new(config.layout.bases[i][1], 0, config.layout.bases[i][2])
				local inVec = baseVec - masterVec + transformVec[i][1]
				local outVec = baseVec - masterVec + transformVec[i][2]
				if config.facing == 1 or config.facing == 3 then
					inVec = vector.new(inVec.z, 0, inVec.x)
					outVec = vector.new(outVec.z, 0, outVec.x)
				end
				fVec = facingVec[config.facing]
				inVec = vector.new(inVec.x * fVec.x, inVec.y * fVec.y, inVec.z * fVec.z)
				outVec = vector.new(outVec.x * fVec.x, outVec.y * fVec.y, outVec.z * fVec.z)
				config.locations[i] = {
					{location = config.location + inVec, capabilities = "accept-items"},
					{location = config.location + outVec, capabilities = "output-items"},
				}
			end
		end
	end
	while true do
		print("What is the name code for this base?")
		print("Base name codes are used to group and differentiate sites.")
		write("> ")
		local baseCode = read()
		if baseCode and #baseCode > 0 then
			config.baseCode = baseCode
			break
		else
			print("A base name code is required!")
		end
	end
	configuration.save("master.conf", config)
end
if not os.loadAPI("storage") then error("Could not load storage API!") end
storage.initialize(config)

peripheral.find("modem", function(name) rednet.open(name) end)

if os.getComputerLabel() then
	rednet.host("lyq-inv", os.getComputerLabel())
else
	print("You must label this computer first.")
	return
end

local itemsStored = 0
local storeControl, sortControl, construction
local clients = {}
local routeQueue = {}
--retrieve and intake are flight queues.
local retrieveQueue, intakeQueue, requestQueue, outputQueue = {}, {}, {{}, {}, {}, {}}, {{}, {}, {}, {}}
local flightQueueTimer = os.startTimer(0)

local direction = {
	--facing north
	{"north", "east", "south", "west"},
	--facing east
	{"east", "south", "west", "north"},
	--facing south
	{"south", "west", "north", "east"},
	--facing west
	{"west", "north", "east", "south"},
}

local function queueFlight(route, queue)
	table.insert(queue, route)
	if not queue.timer then queue.timer = os.startTimer(0) end
end

local function checkRemainingSpace()
	if itemsStored <= 30 then return end
	if storage.getSlotsRemaining() < 120 then
		if construction then
			rednet.send(construction, {event = "build_layer", origin = {x = 0, y = config.layers + 7, z = 0, h = 1}, layer = {x = 0, y = 1, z = 0, h = 1}}, "lyq-inv")
		end
	end
	itemsStored = 0
end

local keepAliveTimer, keepAliveStatus = os.startTimer(5), {false, false, false}

local stationInfo = {
	type = "items-inventory",
	locations = {},
}

for i = 1, 4 do
	if config.layout.bases[i] then
		table.insert(stationInfo.locations, config.locations[i][1])
		table.insert(stationInfo.locations, config.locations[i][2])
	end
end

local clientProtocol = {
	protocol = "lyq-inv",
	name = {
		storage_online = "Storage controller",
		sorting_online = "Sorting controller",
		construction_online = "Construction turtle",
	},
	online = {
		storage_online = true,
		sorting_online = true,
		construction_online = true,
	},
	offline = {
		storage_offline = true,
		sorting_offline = true,
		construction_offline = true,
	},
	list = clients,
}

base.initialize(config.baseCode, stationInfo, nil, clientProtocol)

while true do
	local event = {base.handleEvents(os.pullEventRaw())}
	storeControl, sortControl, construction = (base.getClientByType("storage_online")), (base.getClientByType("sorting_online")), (base.getClientByType("construction_online"))
	if event[1] == "rednet_message" then
		if event[4] == "lyq-inv" then
			local message = event[3]
			if message.type == "store" and event[2] == storeControl then
				print("Storing "..tostring(message.info.count).." of "..message.info.name.."-"..message.info.damage)
				storage.store(message.info, function(route) rednet.send(storeControl, {type = "fly_route", route = route}, "lyq-inv") end)
				itemsStored = itemsStored + 1
				checkRemainingSpace()
			elseif message.type == "retrieve" and event[2] == storeControl then
				print("Retrieved "..tostring(message.info.count).." of "..message.info.name.."-"..message.info.damage)
				local found = false
				for j = 1, math.max(#outputQueue[1], #outputQueue[2], #outputQueue[3], #outputQueue[4]) do
					for i = 1, 4 do
						local info = outputQueue[i][j]
						if info and info.name == message.info.name and info.damage == message.info.damage and (info.count == message.info.count or (info.count > 64 and message.info.count == 64) or mesage.info.count == info.count % 64) then
							info.count = info.count - message.info.count
							local route = storage.createOutputRoute(i)
							table.insert(route, 1, i)
							rednet.send(sortControl, {type = "fly_route", route = route}, "lyq-inv")
							if info.count == 0 then
								table.remove(outputQueue[i], j)
								base.sendToBaseMaster({type = "object_surplus", objectType = "item", objectInfo = {name = info.name, damage = info.damage, count = info.count}, location = config.locations[i][2].location}, "lyq-base")
							end
							found = true
							break
						end
					end
					if found then break end
				end
			elseif message.type == "item_arrived" and event[2] == sortControl then
				print("Received "..tostring(message.info.count).." of "..message.info.name.."-"..message.info.damage)
				local route = storage.createIntakeRoute(message.side)
				table.insert(route, 1, message.side)
				queueFlight(route, intakeQueue)
				for i = 1, #requestQueue[message.side] do
					local info = requestQueue[message.side][i]
					if info and info.name == message.info.name and info.damage == message.info.damage and (info.count == message.info.count or (info.count > 64 and message.info.count == 64) or mesage.info.count == info.count % 64)  then
						info.count = info.count - message.info.count
						if info.count == 0 then
							table.remove(requestQueue[message.side], i)
						end
						break
					end
				end
			elseif message.type == "layer_complete" then
				config.layers = config.layers + 2
				configuration.save("master.conf", config)
				storage.addLayers(message.block, 2)
			end
		elseif event[4] == "lyq-base-inv" and event[3].baseCode == config.baseCode then
			local message = event[3]
			if message.type == "item_count" then
				rednet.send(event[2], {type = "item_quantity", name = message.name, damage = message.damage, count = storage.getItemCount(message.name, message.damage), baseCode = config.baseCode}, "lyq-base-inv")
			elseif message.type == "all_items" then
				rednet.send(event[2], {type = "all_items_info", info = storage.getAllItemCounts(), baseCode = config.baseCode}, "lyq-base-inv")
			elseif message.type == "create_surplus" then
				local itemData = message.objectInfo
				local queueMin, queueChoice = math.huge, -1
				for i = 1, 4 do
					local count = 0
					for j = 1, #outputQueue[i] do
						count = count + outputQueue[i][j].count
					end
					if count < queueMin then
						queueMin = count
						queueChoice = i
					end
				end
				table.insert(outputQueue[queueChoice], itemData)
				print("Retrieving "..tostring(itemData.count).." of "..itemData.name.."-"..itemData.damage)
				local success, count = storage.retrieve(itemData, function(route) queueFlight(route, retrieveQueue) end)
				if not success then
					print("Couldn't retrieve "..count.." items.")
					local queueInfo = outputQueue[queueChoice][#outputQueue[queueChoice]]
					queueInfo.count = queueInfo.count - count
					if queueInfo.count == 0 then
						outputQueue[queueChoice][#outputQueue[queueChoice]] = nil
					end
				end
			elseif message.type == "create_request" then
				local itemData = message.objectInfo
				local queueMin, queueChoice = math.huge, -1
				for i = 1, 4 do
					local count = 0
					for j = 1, #requestQueue[i] do
						count = count + requestQueue[i][j].count
					end
					if count < queueMin then
						queueMin = count
						queueChoice = i
					end
				end
				table.insert(requestQueue[queueChoice], itemData)
				base.sendToBaseMaster({type = "object_required", objectType = "item", objectInfo = itemData, location = config.locations[queueChoice][2].location, baseCode = config.baseCode}, "lyq-base")
			elseif message.type == "free_space" then
				rednet.send(event[2], {type = "free_space_count", info = storage.getSpaceRemaining(), baseCode = config.baseCode}, "lyq-base-inv")
			elseif message.type == "free_slots" then
				rednet.send(event[2], {type = "free_slots_count", info = storage.getSlotsRemaining(), baseCode = config.baseCode}, "lyq-base-inv")
			elseif message.type == "unused_layers" then
			elseif message.type == "item_density" then
				rednet.send(event[2], {type = "item_density_percent", info = storage.calculateItemDensity(), baseCode = config.baseCode}, "lyq-base-inv")
			end
		end
	elseif event[1] == "timer" then
		if event[2] == retrieveQueue.timer then
			if storeControl then
				rednet.send(storeControl, {type = "fly_route", route = table.remove(retrieveQueue, 1)}, "lyq-inv")
			end
			if #retrieveQueue > 0 then
				retrieveQueue.timer = os.startTimer(config.retrievalFlightDelay)
			else
				retrieveQueue.timer = nil
			end
		elseif event[2] == intakeQueue.timer then
			if storeControl then
				rednet.send(sortControl, {type = "fly_route", route = table.remove(intakeQueue, 1)}, "lyq-inv")
			end
			if #intakeQueue > 0 then
				intakeQueue.timer = os.startTimer(config.intakeFlightDelay)
			else
				intakeQueue.timer = nil
			end
		end
	elseif event[1] == "terminate" then
		print("Stopping")
		return
	end
end
