--sorting computer

local config = {
	counters = {},
	bases = {},
}

local directionNames = {"north", "east", "south", "west"}

if not os.loadAPI("configuration") then error("Could not load configuration API!") end

if fs.exists("sorting.conf") then
	config = configuration.load("sorting.conf")
else
	print("Initial Setup for Sorting Controller")
	local counters, bases
	local function c(name)
		table.insert(counters, name)
	end
	local function b(name)
		table.insert(bases, name)
	end
	repeat
		counters = {}
		print("Finding counter peripherals.")
		peripheral.find("counter", c)
		if #counters < 1 then
			print("Please attach at least one counter peripheral to the network.")
			sleep(5)
		elseif #counters > 4 then
			print("Too many counters on the network!  Please attach no more than 4 (one per outside wall).")
			sleep(5)
		end
	until #counters >= 1 and #counters <= 4
	for i = 1, #counters do
		print("Which wall is "..counters[i].." located on?")
		for i = 1, 4 do
			if not config.counters[i] then
				print(i..". "..directionNames[i])
			end
		end
		local answer
		repeat
			answer = tonumber(read())
			if answer and config.counters[answer] == nil then
				config.counters[answer] = counters[i]
				break
			else
				answer = nil
			end
		until answer
	end
	repeat
		bases = {}
		print("Finding quadracoptor base peripherals.")
		peripheral.find("quadbase", b)
		if #bases ~= #counters then
			print("Please attach to the network one quadracoptor base for each counter peripheral.")
			sleep(5)
		end
	until #bases == #counters
	for i = 1, #bases do
		print("Which wall is "..bases[i].." located on?")
		for i = 1, 4 do
			if config.counters[i] and not config.bases[i] then
				print(i..". "..directionNames[i])
			end
		end
		local answer
		repeat
			write("? ")
			answer = tonumber(read())
			if answer and config.counters[answer] and config.bases[answer] == nil then
				config.bases[answer] = bases[i]
				break
			else
				answer = nil
			end
			print("Please select a valid option.")
		until answer
	end
	configuration.save("sorting.conf", config)
end

local counterLookup, baseLookup = {}, {}
for i = 1, 4 do
	if config.counters[i] then
		counterLookup[config.counters[i]] = i
	end
	if config.bases[i] then
		counterLookup[config.bases[i]] = i
	end
end

local master

peripheral.find("modem", function(name) rednet.open(name) end)

local keepAliveTimer

local function waitForMaster()
	local hosts
	repeat
		print("Searching for backend...")
		hosts = {rednet.lookup("lyq-inv")}
		if #hosts > 1 then
			print("Multiple backends found! Please remove all but one from this network.")
			sleep(5)
		elseif #hosts < 1 then
			print("No backend found! Please add one to this network.")
			sleep(5)
		end
	until #hosts == 1

	master = hosts[1]
	print("Attempting to connect to backend. ("..tostring(master)..")")
	rednet.send(master, {event = "sorting_online"}, "lyq-inv")
	keepAliveTimer = os.startTimer(7)
end

waitForMaster()

while true do
	local event = {os.pullEventRaw()}
	if event[1] == "item_count" then
		rednet.send(master, {event = "item_arrived", side = counterLookup[event[2]], info = {name = event[3], damage = event[4], count = event[5]}}, "lyq-inv")
	elseif event[1] == "rednet_message" and event[4] == "lyq-inv" then
		if event[2] == master then
			if event[3].event == "fly_route" then
				local side = table.remove(event[3].route, 1)
				peripheral.call(config.bases[side], "flyQuad", event[3].route)
			elseif event[3].event == "master_online" then
				print("Connected to backend. ("..tostring(event[2])..")")
				keepAliveTimer = os.startTimer(7)
			elseif event[3].event == "master_offline" then
				print("Backend went offline.")
				waitForMaster()
			elseif event[3].event == "keepalive_ping" then
				rednet.send(master, {event = "keepalive_pong"}, "lyq-inv")
				keepAliveTimer = os.startTimer(7)
			end
		end
	elseif event[1] == "timer" and event[2] == keepAliveTimer then
		print("Backend timed out.")
		waitForMaster()
	elseif event[1] == "terminate" then
		if master then rednet.send(master, {event = "sorting_offline"}, "lyq-inv") end
		print("Stopping")
		return
	end
end
